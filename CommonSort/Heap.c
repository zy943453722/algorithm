/*************************************************************************
	> File Name: Heap.c
	> Author: ZhangYue
	> Mail: zy943453722@gmail.com
	> Created Time: 2018年03月17日 星期六 19时54分35秒
 ************************************************************************/
/**
 * 堆排序：属于选择排序的一种，另一种是简单选择排序，想法也是找到最大或最小值
 * 性能:空间复杂度：O(1) 时间复杂度:最好：O(nlogn) 平均：O(nlogn) 最差:O(nlogn)
 * 稳定性:不稳定
 * 思路：1. 将待排序的数列转化成一个大顶堆或者小顶堆
 *       2.依次取大顶堆或者小顶堆根节点元素放到数组的末尾或者首部
 *       3.将剩余元素再转化成一个大顶堆，继续上述操作，直到取完数据
 *解答：1.转化为大顶堆或小顶堆的过程，实际是从下往上从左往右，将每个非叶节点当做根节点，即
 *       根据堆的性质，根节点i的左右孩子为2i+1和2i+2(这是对下标而言，对于数字而言，是i对应2i和2i+1)
 *       所以先要找到最后一个非叶子节点，调整节点，还原子树
 *       2.之后同样的方法还原子树
 *       调整节点的方法：找出父节点的两个子节点的较大值和父节点比较，若大，则交换，小则退出循环
 */ 
#include<stdio.h>
#include<stdlib.h>
#include "sort.h"
void HeapSort(Sqlist *l)
{
    for(int i = (l->length >> 1) - 1; i >= 0; i--)//从最后一个非叶子节点构造最大堆
    {
        HeapAdjust(l,i,l->length);
    }
    for(int i = length - 1; i > 0; i--)
    {
        Swap(l,i,0);//交换根节点和尾部节点，保存在尾部
        HeapAdjust(l,i,i-1);
    }
}
void HeapAdjust(Sqlist *l,int i,int length)
{
    for(j = 2 * i + 1; j <= length; j *= 2)//先从最左侧的子孩子开始
    {
        int t = l->list[i];//定下当前的根节点值
        if(j < length && l->list[j] < l->list[j+1])
            j++;//左孩子小于右孩子
        if(temp >= l->list[j])
           break;//不用调整
        l->list[i] = l->list[j];//将大的叶子节点调整成父节点
        i = j;
    }
    l->list[i] = temp;//放好这个根节点的值
}
